<!doctype html>
<html lang="id">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1, viewport-fit=cover" />
<title>EduBros ‚Äî Star Hunt Quiz (Playful, Final)</title>
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
<style>
  :root{
    --bg-top:#9bd8ff; --bg-bot:#ffd7a6;
    --card: rgba(255,255,255,0.95);
    --muted:#6b7080;
    --accent:#FF8A65;
    --accent2:#6C5CE7;
    --shadow: 0 12px 30px rgba(23,23,40,0.12);
  }
  *{box-sizing:border-box}
  html,body{height:100%; margin:0; background:linear-gradient(180deg,var(--bg-top),var(--bg-bot)); color:#25303d; font-family:'Poppins',system-ui, Arial, sans-serif; -webkit-font-smoothing:antialiased}
  #wrap{display:flex;align-items:center;justify-content:center;min-height:100vh;padding:env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left)}

  .canvas-wrap{width:min(1100px, calc(100vw - 28px)); max-width:100%; aspect-ratio:16/9; background:linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0.01)); border-radius:14px; overflow:hidden; display:flex; align-items:center; justify-content:center; border:2px solid rgba(255,255,255,0.06); box-shadow:var(--shadow); position:relative}
  canvas{width:100%; height:100%; display:block; image-rendering:pixelated; background:transparent}

  .overlay{position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(12,14,20,0.45); z-index:60; padding:16px}
  .card{width:min(880px,96vw); background:var(--card); border-radius:14px; padding:18px; border:1px solid rgba(0,0,0,0.06); box-shadow: var(--shadow)}
  .title{font-weight:700}
  .muted{color:var(--muted); font-size:14px}
  .btn{display:inline-block;padding:10px 14px;border-radius:10px;border:2px solid rgba(0,0,0,0.06);background:#ffffff;color:inherit;cursor:pointer;font-weight:600}
  .btn.primary{background:linear-gradient(180deg,var(--accent),#ff6f3f);border-color:rgba(0,0,0,0.06); color:white}
  .btn.ghost{background:transparent;border:2px dashed rgba(0,0,0,0.06)}
  .btnbar{display:flex;gap:10px;flex-wrap:wrap;justify-content:center;margin-top:12px}
  .center{text-align:center}

  #touch{position:fixed;left:env(safe-area-inset-left);right:env(safe-area-inset-right);bottom:env(safe-area-inset-bottom);display:flex;justify-content:space-between;padding:12px;gap:8px;pointer-events:none;z-index:50}
  .pad{pointer-events:auto;display:flex;gap:8px}
  .pad .key,.pad .jump{width:64px;height:64px;border-radius:12px;border:2px solid rgba(0,0,0,0.06);background:linear-gradient(180deg,rgba(255,255,255,0.9),rgba(255,255,255,0.8));display:flex;align-items:center;justify-content:center;font-weight:700;user-select:none;box-shadow:0 6px 18px rgba(0,0,0,0.08)}
  .pad .jump{width:88px}
  .pad .key:active, .pad .jump:active{transform:translateY(2px);}

  #quiz .card{max-width:520px; width:100%}
  #qTitle{color:var(--accent2)}
  #qChoices{display:flex;flex-direction:column;gap:10px}
  #qChoices button{display:flex;gap:10px;align-items:center;padding:10px;border-radius:10px;border:1px solid rgba(0,0,0,0.06);background:linear-gradient(180deg,rgba(255,255,255,0.98),rgba(255,255,255,0.92));cursor:pointer;font-weight:600}
  #qChoices button .dot{width:18px;height:18px;border-radius:6px;background:var(--accent);display:inline-block}
  #qFeedback{min-height:20px;color:#2f3b47}

  #loading .card{width:360px;text-align:center}
  progress{width:90%;height:12px;border-radius:8px;overflow:hidden}

  #unansweredList{max-height:220px; overflow:auto; padding:8px; border-radius:8px; background:linear-gradient(180deg, rgba(108,92,231,0.06), rgba(255,138,101,0.04)); margin-top:8px}

  #gameOver .card{max-width:520px}
  #mobileInfo{display:none; font-size:13px; color:#123; margin-top:8px; text-align:center;}
  @media (max-width:720px){ .canvas-wrap{aspect-ratio:16/10} #mobileInfo{display:block} }
</style>
</head>
<body>
  <div id="wrap">
    <div class="canvas-wrap" role="application" aria-label="EduBros Game Area">
      <canvas id="game" aria-label="EduBros Game Canvas"></canvas>
    </div>
  </div>

  <!-- Overlays -->
  <div id="menu" class="overlay" style="display:flex" role="dialog" aria-modal="true">
    <div class="card center">
      <div style="display:flex;gap:12px;align-items:center;justify-content:center">
        <div style="width:72px;height:72px;border-radius:14px;background:linear-gradient(135deg,#FFD54F,#FF8A65);display:flex;align-items:center;justify-content:center;font-weight:800;font-size:28px;color:#2a2a2a;box-shadow:0 8px 22px rgba(0,0,0,0.08)">‚òÖ</div>
        <div style="text-align:left">
          <div class="title" style="font-size:36px;color:#2b2b2b">EduBros</div>
          <div class="muted">Star-Hunt Quiz ‚Äî Platformer & Kuis (Playful)</div>
        </div>
      </div>

      <p style="text-align:left;margin-top:12px;color:#25303d">Aturan singkat:
      <ul style="text-align:left;color:#25303d">
        <li>Kontrol: ‚Üê ‚Üí bergerak, ‚Üë / Spasi = lompat.</li>
        <li>Per stage ada 8 bintang; sebagian berisi soal, sebagian kosong.</li>
        <li>Jawab soal saat kena bintang ‚Äî jawaban <b>tidak perlu benar</b> untuk membuka stage; benar/salah hanya tercatat untuk hasil akhir.</li>
      </ul>
      </p>
      <div class="btnbar" style="margin-top:12px">
        <button id="startBtn" class="btn primary">Mulai</button>
        <button id="howBtn" class="btn">Cara Main</button>
      </div>
      <div class="muted" style="margin-top:10px">Versi: final ‚Äî playable, smooth, responsif</div>
    </div>
  </div>

  <div id="how" class="overlay" role="dialog" aria-modal="true">
    <div class="card">
      <div class="title" style="font-size:20px;color:var(--accent2)">Cara Main</div>
      <ol style="margin-top:8px;color:#25303d">
        <li>Kumpulkan bintang ‚Äî beberapa punya soal.</li>
        <li>Kuis mem-pause game. Pilih jawaban. Jawaban tetap dihitung, benar atau salah.</li>
        <li>Jawaban (benar/salah) akan meningkatkan progress stage. Setelah cukup, gerbang terbuka.</li>
        <li>Hati-hati lubang berduri ‚Äî jangan jatuh ke dalam. Gunakan lompat flowy untuk melewati.</li>
      </ol>
      <div class="btnbar" style="margin-top:12px">
        <button class="btn" onclick="toggleOverlay('how',false)">Tutup</button>
      </div>
    </div>
  </div>

  <div id="quiz" class="overlay" role="dialog" aria-modal="true">
    <div class="card">
      <div class="title" id="qTitle" style="font-size:18px">Pertanyaan</div>
      <div id="qText" style="margin-top:8px;color:#25303d;font-weight:600"></div>
      <div id="qChoices" style="margin-top:12px"></div>
      <div id="qFeedback" class="muted" style="margin-top:8px"></div>
      <div class="btnbar" style="margin-top:12px">
        <button id="skipBtn" class="btn ghost" title="Tutup kuis, bintang tetap bisa dihitung">Lewati</button>
      </div>
    </div>
  </div>

  <div id="loading" class="overlay" role="dialog" aria-modal="true">
    <div class="card center">
      <div class="title" style="font-size:22px;color:#2b2b2b">Memuat Dunia EduBros‚Ä¶</div>
      <div class="muted" style="margin-top:8px">Menyiapkan level, soal, dan musik</div>
      <div style="margin-top:12px"><progress id="prog" max="100" value="0"></progress></div>
      <div class="muted" style="margin-top:10px">Tip: Gunakan tombol panah untuk bergerak ‚Äî tombol sentuh tampil pada perangkat layar sentuh</div>
    </div>
  </div>

  <div id="win" class="overlay" role="dialog" aria-modal="true">
    <div class="card">
      <div class="title" style="font-size:20px;color:var(--accent2)">Permainan Selesai</div>
      <div id="winStats" style="margin-top:10px;color:#25303d"></div>
      <div id="unansweredSection" style="margin-top:8px">
        <div class="muted">Soal yang tidak terjawab:</div>
        <div id="unansweredList"></div>
      </div>
      <div class="btnbar" style="margin-top:12px">
        <button id="playAgainBtn" class="btn primary">Main Lagi</button>
        <button id="reviewBtn" class="btn">Ulangi Soal Belum Terjawab</button>
      </div>
    </div>
  </div>

  <div id="gameOver" class="overlay" role="dialog" aria-modal="true">
    <div class="card center">
      <div class="title" style="font-size:28px;color:#2b2b2b">GAME OVER üíÄ</div>
      <div class="muted" style="margin-top:8px;color:#25303d">Nyawamu habis ‚Äî coba ulang stage atau kembali ke menu</div>
      <div class="btnbar" style="margin-top:14px">
        <button id="retryBtn" class="btn primary">Coba Lagi</button>
        <button id="toMenuBtn" class="btn">Kembali ke Menu</button>
      </div>
    </div>
  </div>

  <!-- Touch controls (visible on touch devices) -->
  <div id="touch" aria-hidden="false">
    <div class="pad">
      <div class="key" data-k="ArrowLeft">‚Üê</div>
      <div class="key" data-k="ArrowRight">‚Üí</div>
    </div>
    <div class="pad">
      <div class="jump" data-k="Space">Lompat</div>
    </div>
  </div>

  <div id="mobileInfo" style="max-width:1100px;margin:12px auto;text-align:center;color:#123;">
    Kontrol layar tersedia di bawah ‚Äî geser / gunakan tombol untuk bergerak.
  </div>

<script>
(() => {
  'use strict';
  // --- BASE logical resolution ---
  const BASE_W = 960, BASE_H = 540;
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', {alpha:true});

  // physics constants (tuned for flowy jump)
  const groundY = BASE_H - 60;
  const WORLD_END_X = 9800;

  const PAL = {
    bgTop:'#9bd8ff', bgBottom:'#ffd7a6',
    ground1:'#9be7c4', ground2:'#6fe7c9',
    block:'#6c5ce7', blockEdge:'#4630b3',
    star:'#ffd95a', starEdge:'#ffb700',
    player:'#34d3bf', playerEdge:'#1aa38f',
    enemy:'#ff7b7b', enemyEdge:'#ff3b3b',
    text:'#25303d',
    accent:'#ff8a65', accent2:'#6c5ce7'
  };

  const state = {
    scene:'menu', camX:0,
    keys:{}, touch:{left:false,right:false},
    gravity:0.6, friction:0.72,
    lives:3, checkpointX:60,
    correct: new Set(), wrong: new Set(),
    usedQuizIndices: new Set(),
    stageAnswered:[],
    pendingQuestion: null, pendingStar: null,
    quizCooldownUntil:0, toast: null,
    shakeUntil:0, particles: []
  };

  // level (platforms, moving, enemies) -- reuse earlier layout
  const barriers = [
    {x:2200, y:0, w:20, h:groundY, opened:false, need:3},
    {x:4600, y:0, w:20, h:groundY, opened:false, need:3},
    {x:7000, y:0, w:20, h:groundY, opened:false, need:3},
    {x:9400, y:0, w:20, h:groundY, opened:false, need:4}
  ];
  const STAGE_COUNT = barriers.length;
  const STAGE_BOUNDS = (function mkBounds(){ const B=[]; for(let i=0;i<STAGE_COUNT;i++){ const start = i===0?0:(barriers[i-1].x+barriers[i-1].w); const end = barriers[i].x; B.push({start,end}); } return B; })();

  const staticPlatforms = [
    {x:0,    y:groundY, w:2200, h:60},
    {x:2220, y:groundY, w:2380, h:60},
    {x:4620, y:groundY, w:2380, h:60},
    {x:7020, y:groundY, w:2380, h:60},
    {x:9420, y:groundY, w:260,  h:60},

    {x:260,  y:groundY-110, w:140, h:20},
    {x:520,  y:groundY-170, w:140, h:20},
    {x:820,  y:groundY-130, w:160, h:20},
    {x:1300, y:groundY-190, w:160, h:20},

    {x:2400, y:groundY-150, w:160, h:20},
    {x:2760, y:groundY-210, w:160, h:20},
    {x:3160, y:groundY-150, w:160, h:20},
    {x:3540, y:groundY-210, w:160, h:20},

    {x:4800, y:groundY-150, w:160, h:20},
    {x:5160, y:groundY-210, w:160, h:20},
    {x:5560, y:groundY-150, w:160, h:20},
    {x:5940, y:groundY-210, w:160, h:20},

    {x:7200, y:groundY-150, w:160, h:20},
    {x:7560, y:groundY-210, w:160, h:20},
    {x:7960, y:groundY-150, w:160, h:20},
    {x:8340, y:groundY-210, w:160, h:20},
  ];

  const movingPlatforms = [
    {x:2000,y:groundY-180,w:160,h:20, dir:1, speed:0.9, min:1900, max:2120, dx:0},
    {x:4380,y:groundY-200,w:160, dir:-1,speed:0.8, min:4240, max:4500, dx:0},
    {x:6780,y:groundY-180,w:160, dir:1, speed:1.0, min:6660, max:6920, dx:0},
    {x:9180,y:groundY-200,w:160, dir:-1,speed:0.7, min:9040, max:9320, dx:0}
  ];

  // spike pits (holes) replace earlier spikes on top of ground
  const spikePits = [
    {x:1700, w:140}, {x:4100, w:140}, {x:6500, w:140}, {x:8900, w:140}
  ];

  const enemies = [
    {x:840,  y:groundY-28, w:28, h:28, dir:-1, speed:1.1, min:760,  max:920},
    {x:3050, y:groundY-28, w:28, h:28, dir:1,  speed:1.2, min:2960, max:3160},
    {x:5450, y:groundY-28, w:28, h:28, dir:-1, speed:1.0, min:5360, max:5560},
    {x:7850, y:groundY-28, w:28, h:28, dir:1,  speed:1.1, min:7760, max:7960}
  ];

  const goal = {x:WORLD_END_X-120, y:groundY-120, w:18, h:120};

  // player (tuned)
  const player = { x:60, y:groundY-40, w:28, h:40, vx:0, vy:0, onGround:false, facing:1 };
  // jump tuning
  const JUMP_V = -16; // stronger initial impulse
  const MAX_WALK_SPEED = 5.6;

  // quiz bank (same)
  const QUIZ = [ /* same list as earlier - shortened here for brevity; full set is identical to previous version */ 
    {q:"Hasil dari 16 ¬Ω √ó 27 ‚Öî adalah ‚Ä¶", choices:["24","144","12","36"], correct:3, tag:"Aritmetika"},
    {q:"Deret aritmetika dimulai dari 6 dan beda 7. Suku ke-10 adalah ‚Ä¶", choices:["62","63","64","65"], correct:2, tag:"Barisan"},
    {q:"Luas trapesium sisi sejajar 12 cm dan 20 cm, tinggi 9 cm adalah ‚Ä¶", choices:["96 cm¬≤","108 cm¬≤","120 cm¬≤","144 cm¬≤"], correct:1, tag:"Bangun Datar"},
    {q:"Pola segitiga: 1, 3, 6, 10, ‚Ä¶ Jumlah titik pada susunan ke-7 adalah ‚Ä¶", choices:["28","27","21","36"], correct:0, tag:"Pola Bilangan"},
    {q:"Jika f(x)=2x+7 dan g(x)=x¬≤‚àí2x+1, maka (f‚àòg)(‚àí1) = ‚Ä¶", choices:["9","11","13","15"], correct:3, tag:"Fungsi"},
    {q:"Diketahui f(x)=2x+8 dan g(x)=4x‚àí8. Nilai (f‚àòg)(x) adalah ‚Ä¶", choices:["8x‚àí16","8x‚àí8","6x‚àí8","4x‚àí8"], correct:1, tag:"Fungsi"},
    {q:"Jika f(x)=3x+8 dan (f‚àòg)(x)=3x‚àí1, maka g(10) = ‚Ä¶", choices:["5","6","7","8"], correct:2, tag:"Fungsi"},
    {q:"Diketahui f(x)=2x+5 dan g(x)=x‚àí1. Jika (f‚àòg)(a)=13, maka a = ‚Ä¶", choices:["6","3","4","5"], correct:3, tag:"Fungsi"},
    {q:"f(x)=3x+6. Nilai f‚Åª¬π(15) adalah ‚Ä¶", choices:["3","4","5","6"], correct:0, tag:"Fungsi Invers"},
    {q:"Di Rejeki: buku Rp8.000, penghapus Rp3.500, bolpoin Rp6.500. Di Makmur: buku Rp9.000, penghapus Rp3.000, bolpoin Rp6.000. Pernyataan benar adalah ‚Ä¶",
     choices:[
       "Harga buku tulis di Rejeki lebih mahal dari Makmur.",
       "Harga buku tulis di Rejeki lebih murah dari Makmur.",
       "Harga penghapus di Rejeki sama dengan di Makmur.",
       "Harga penghapus di Rejeki lebih murah dari Makmur.",
       "Harga bolpoin di Rejeki lebih murah dari Makmur."
     ], correct:1, tag:"Numerasi"},
    {q:"Rudi punya 120 kelereng. Setelah pembagian seperti soal, selisih paling banyak dengan temannya adalah ‚Ä¶", choices:["23","22","20","14","4"], correct:2, tag:"Persentase"},
    {q:"Toko membeli 30 buku @Rp40.000 dan ongkir Rp150.000. Dijual @Rp50.000. Keuntungan total adalah ‚Ä¶", choices:["Rp200.000","Rp250.000","Rp300.000","Rp350.000"], correct:2, tag:"Keuangan"},
    {q:"Di kelas ada 12 laki-laki dan 8 perempuan. Peluang terpilih perempuan adalah ‚Ä¶", choices:["1/2","2/5","3/5","1/4"], correct:1, tag:"Peluang"},
    {q:"Dadu 6 sisi dilempar sekali. (a) genap, (b) ganjil > 3. Peluangnya ‚Ä¶", choices:["1/2 dan 1/6","1/3 dan 1/2","1/2 dan 1/3","2/3 dan 1/6"], correct:0, tag:"Peluang"},
    {q:"Stok beras 75 kg. Dijual tiap hari bertambah 5 kg, mulai 5 kg hari pertama. Berapa hari sampai habis?", choices:["5 hari","8 hari","10 hari","12 hari"], correct:0, tag:"Barisan"},
    {q:"Menabung bulan pertama Rp250.000, tiap bulan naik Rp50.000. Total 6 bulan adalah ‚Ä¶", choices:["Rp2.250.000","Rp2.400.000","Rp2.550.000","Rp2.700.000"], correct:0, tag:"Barisan"},
    {q:"Bakteri menjadi 3√ó tiap 30 menit. Jika awal 2 bakteri, setelah pembelahan ke-4 jumlahnya ‚Ä¶", choices:["54","81","108","162"], correct:3, tag:"Pertumbuhan"},
    {q:"Modal Rp1.000.000 bertambah 20% tiap bulan. Nilai modal pada bulan ke-3 adalah ‚Ä¶", choices:["Rp1.440.000","Rp1.728.000","Rp2.000.000","Rp2.400.000"], correct:1, tag:"Pertumbuhan"},
    {q:"(2a + 3b ‚àí 4) + (a ‚àí 3b + 2) = ‚Ä¶", choices:["3a ‚àí 2","a + b ‚àí 2","3a + 2b ‚àí 2","2a ‚àí 2"], correct:0, tag:"Aljabar"},
    {q:"Sederhanakan: 4(3a + 2) ‚àí 3(6a ‚àí 5) = ‚Ä¶", choices:["6a + 23","‚àí6a + 23","‚àí12a ‚àí 7","‚àí6a ‚àí 23"], correct:1, tag:"Aljabar"}
  ];

  const STARS_PER_STAGE = 8;
  let quizStars = [];

  // helpers
  function randInt(n){ return (Math.random()*n)|0; }
  function shuffle(arr){ const a=arr.slice(); for(let i=a.length-1;i>0;i--){const j=(Math.random()*(i+1))|0; [a[i],a[j]]=[a[j],a[i]];} return a; }

  function genStarsForStages(){
    quizStars = [];
    state.usedQuizIndices.clear();
    state.stageAnswered = Array(STAGE_COUNT).fill(0);
    const allIdx = Array.from({length:QUIZ.length}, (_,i)=>i);
    let pool = shuffle(allIdx), poolPos=0;
    function nextQuizIndex(){ if(poolPos>=pool.length){ pool=shuffle(allIdx); poolPos=0;} const v=pool[poolPos++]; state.usedQuizIndices.add(v); return v; }

    for (let s=0;s<STAGE_COUNT;s++){
      const {start,end} = STAGE_BOUNDS[s];
      const left = start + 140, right = end - 140;
      const span = Math.max(200, right - left);
      const need = barriers[s].need;
      const target = Math.round(STARS_PER_STAGE * 0.6);
      const quizCount = Math.min(STARS_PER_STAGE, Math.max(need+1, target));
      const quizSlots = new Set(shuffle(Array.from({length:STARS_PER_STAGE},(_,i)=>i)).slice(0, quizCount));
      for (let k=0;k<STARS_PER_STAGE;k++){
        const base = left + (k+0.5)*(span / STARS_PER_STAGE);
        const jitter = (Math.random()*160 - 80);
        const x = clamp(Math.floor(base + jitter), left+40, right-40);
        const yOptions = [groundY-30, groundY-90, groundY-150, groundY-210];
        const y = yOptions[randInt(yOptions.length)];
        if (quizSlots.has(k)){
          quizStars.push({x,y,w:18,h:18, active:true, stage:s, locked:false, quiz:true, quizIndex: nextQuizIndex()});
        } else {
          quizStars.push({x,y,w:18,h:18, active:true, stage:s, locked:false, quiz:false, quizIndex:null});
        }
      }
    }
  }

  function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }
  function rectsOverlap(a,b){ return a.x < b.x+b.w && a.x+a.w > b.x && a.y < b.y+b.h && a.y+a.h > b.y; }

  // Responsive canvas & DPR
  let SCALE = 1;
  function resizeCanvas(){
    const wrap = document.querySelector('.canvas-wrap');
    const cssW = Math.max(320, Math.min(1100, wrap.clientWidth));
    const cssH = Math.round(cssW * (BASE_H / BASE_W));
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.style.width = cssW + 'px';
    canvas.style.height = cssH + 'px';
    canvas.width = Math.round(cssW * dpr);
    canvas.height = Math.round(cssH * dpr);
    SCALE = cssW / BASE_W;
    ctx.setTransform(dpr * SCALE, 0, 0, dpr * SCALE, 0, 0);
  }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  // input
  const keyMap = { ' ': 'Space', Spacebar:'Space', Left:'ArrowLeft', Right:'ArrowRight', Up:'ArrowUp' };
  function normKey(k){ return keyMap[k] || k; }
  window.addEventListener('keydown', e=>{ const k=normKey(e.key); if(['ArrowLeft','ArrowRight','ArrowUp','Space'].includes(k)) e.preventDefault(); state.keys[k]=true; }, {passive:false});
  window.addEventListener('keyup', e=>{ const k=normKey(e.key); state.keys[k]=false; }, {passive:false});
  const tpanel = document.getElementById('touch');
  try{ if(!(window.matchMedia && window.matchMedia('(pointer: coarse)').matches)) tpanel.style.display='none'; }catch(e){}
  tpanel.addEventListener('touchstart', e=>{ const t=e.target.closest('[data-k]'); if(t){ e.preventDefault(); pressKey(t.dataset.k, true); } }, {passive:false});
  tpanel.addEventListener('touchend', e=>{ const t=e.target.closest('[data-k]'); if(t){ e.preventDefault(); pressKey(t.dataset.k, false); } }, {passive:false});
  function pressKey(k, down){ if(k==='ArrowLeft') state.touch.left=down; if(k==='ArrowRight') state.touch.right=down; if(k==='Space'&&down) doJump(); }

  // Sound via WebAudio (simple tones)
  const audioCtx = new (window.AudioContext||window.webkitAudioContext)();
  function playTone(freq, time=0.08, type='sine', vol=0.12){
    try{
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = type; o.frequency.value = freq;
      g.gain.value = vol;
      o.connect(g); g.connect(audioCtx.destination);
      o.start();
      g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + time);
      setTimeout(()=>{ try{ o.stop(); o.disconnect(); g.disconnect(); }catch(_){} }, time*1000+50);
    }catch(e){}
  }

  // Jump handling (flowy)
  let jumpHeld = false;
  function doJump(){
    if (player.onGround){
      player.vy = JUMP_V;
      player.onGround = false;
      spawnJumpParticles();
      playTone(520, 0.12, 'sine', 0.12);
      // small camera shake on big jump
      state.shakeUntil = Date.now() + 120;
    }
  }

  // physics helpers
  function updateMovingPlatforms(){
    for (const p of movingPlatforms){
      const dx = p.speed * p.dir;
      p.x += dx;
      if (p.x < p.min){ p.x = p.min; p.dir = 1; }
      if (p.x + p.w > p.max){ p.x = p.max - p.w; p.dir = -1; }
      p.dx = dx;
    }
  }
  function carryWithMovingPlatform(){
    for (const p of movingPlatforms){
      const onTop = player.onGround && Math.abs((player.y + player.h) - p.y) < 1.8 && player.x + player.w > p.x && player.x < p.x + p.w;
      if (onTop){ player.x += (p.dx || 0); }
    }
  }
  function collideWorldX(objs){
    for (const o of objs) if (rectsOverlap(player,o)){
      if (player.vx > 0) player.x = o.x - player.w;
      else if (player.vx < 0) player.x = o.x + o.w;
      player.vx = 0;
    }
  }
  function collideWorldY(objs){
    for (const o of objs) if (rectsOverlap(player,o)){
      if (player.vy > 0){ player.y = o.y - player.h; player.vy = 0; player.onGround = true; }
      else if (player.vy < 0){ player.y = o.y + o.h; player.vy = 0; }
    }
  }

  function handleInput(){
    const left = state.keys['ArrowLeft'] || state.touch.left;
    const right = state.keys['ArrowRight'] || state.touch.right;
    const jumpKey = state.keys['ArrowUp'] || state.keys['Space'];

    if (left && !right){ player.vx -= 0.7; player.facing = -1; }
    if (right && !left){ player.vx += 0.7; player.facing = 1; }
    if (!left && !right){ player.vx *= state.friction; }
    player.vx = clamp(player.vx, -MAX_WALK_SPEED, MAX_WALK_SPEED);

    // variable gravity for flowy jump: lower gravity while ascending, higher when falling
    if ((jumpKey || jumpHeld) && !player.onGround && player.vy < 0){
      // lighter ascent (allow slight hold)
      player.vy += state.gravity * 0.42;
    } else {
      // normal gravity (faster fall)
      player.vy += state.gravity * 1.05;
    }
    // jumping trigger
    if (jumpKey && player.onGround){ doJump(); }
  }

  function updateEnemies(){
    for (const m of enemies){
      m.x += m.speed * m.dir;
      if (m.x < m.min){ m.x = m.min; m.dir = 1; }
      if (m.x + m.w > m.max){ m.x = m.max - m.w; m.dir = -1; }
      if (rectsOverlap(player, m)){
        if (player.vy > 2){ player.vy = -9; m.min -= 6; m.max += 6; }
        else { hitTrap(); }
      }
    }
  }

  function hitTrap(){
    // lose a life, shake, respawn at checkpoint
    state.lives -= 1;
    spawnHurtParticles();
    playTone(160, 0.22, 'square', 0.16);
    state.shakeUntil = Date.now() + 260;
    if (state.lives < 0){
      // game over
      toggleOverlay('gameOver', true);
      state.scene = 'menu-paused';
      playTone(120, 0.5, 'sawtooth', 0.22);
      return;
    }
    // respawn
    player.x = state.checkpointX; player.y = groundY - 80; player.vx = 0; player.vy = 0;
    toast('Kamu terkena jebakan! Respawn...', 1200);
  }

  function toast(msg, dur=1000){
    state.toast = {msg, until: Date.now() + dur};
  }

  // collect / trigger stars (quiz)
  function collectQuizStars(){
    if (state.pendingQuestion || Date.now() < state.quizCooldownUntil) return;
    for (const s of quizStars){
      if (!s.active || s.locked) continue;
      if (rectsOverlap(player, s)){
        if (s.quiz){
          const qi = s.quizIndex;
          state.pendingStar = s;
          state.pendingQuestion = { ...QUIZ[qi], idx: qi, stage: s.stage };
          s.locked = true;
          showQuiz(state.pendingQuestion);
        } else {
          s.active = false; s.locked = false;
          state.checkpointX = Math.max(state.checkpointX, player.x - 10);
          toast('Bintang kosong ‚Äî lanjut!', 900);
          state.quizCooldownUntil = Date.now() + 300;
        }
        break;
      }
    }
  }

  // spike pit check: if player's feet inside pit area and not jumping high -> die
  function checkSpikePits(){
    for (const p of spikePits){
      const px = p.x, pw = p.w;
      // if player's horizontal center within pit and player's feet at ground level (fell into pit)
      const centerX = player.x + player.w/2;
      if (centerX > px && centerX < px + pw){
        // If player's feet touch the pit bottom (i.e., y+h >= groundY - 6) => hit
        if (player.y + player.h >= groundY - 6){
          // kill
          hitTrap();
          return;
        }
      }
    }
  }

  function checkPitFall(){ if (player.y > groundY + 160) { hitTrap(); } }

  function checkBarriersOpenByProgress(){
    for (let i=0;i<barriers.length;i++){
      const b = barriers[i];
      if (!b.opened && state.stageAnswered[i] >= b.need){ b.opened = true; }
    }
  }

  function checkWin(){ if (rectsOverlap(player, goal)) { state.scene = 'win'; showWinOverlay(); } }

  // --- QUIZ UI & logic ---
  function showQuiz(q){
    const qText = document.getElementById('qText');
    const qChoices = document.getElementById('qChoices');
    const qTitle = document.getElementById('qTitle');
    const qFeedback = document.getElementById('qFeedback');

    qTitle.textContent = `KUIS ‚Ä¢ ${q.tag || 'Soal'}`;
    qText.textContent = q.q;
    qChoices.innerHTML = '';
    qFeedback.textContent = '';

    q.choices.forEach((c, idx)=>{
      const btn = document.createElement('button');
      btn.className = 'btn';
      btn.style.justifyContent = 'flex-start';
      btn.innerHTML = `<span class="dot" style="background:${PAL.accent2}"></span> <span style="flex:1">${c}</span>`;
      btn.onclick = ()=> answerQuestion(q, idx);
      qChoices.appendChild(btn);
    });

    document.getElementById('skipBtn').onclick = ()=>{
      toggleOverlay('quiz', false);
      if (state.pendingStar) state.pendingStar.locked = false;
      state.pendingQuestion = null;
      state.pendingStar = null;
      state.quizCooldownUntil = Date.now() + 800;
    };

    toggleOverlay('quiz', true);
    player.vx = 0;
  }

  function answerQuestion(q, idx){
    const qFeedback = document.getElementById('qFeedback');
    if (idx === q.correct){
      qFeedback.textContent = '‚úÖ Benar!';
      state.correct.add(q.idx);
      playTone(720, 0.12, 'sine', 0.12);
    } else {
      qFeedback.textContent = `‚ùå Salah ‚Äî jawaban benar: ${q.choices[q.correct]}`;
      state.wrong.add(q.idx);
      playTone(180, 0.14, 'sawtooth', 0.14);
    }

    if (state.pendingStar){
      state.pendingStar.active = false; state.pendingStar.locked = false;
      state.checkpointX = Math.max(state.checkpointX, player.x - 10);
      const sidx = state.pendingStar.stage;
      state.stageAnswered[sidx] = Math.min((state.stageAnswered[sidx]||0) + 1, 99);
    }

    setTimeout(()=>{
      toggleOverlay('quiz', false);
      state.pendingQuestion = null; state.pendingStar = null;
      state.quizCooldownUntil = Date.now() + 600;
      checkBarriersOpenByProgress();
    }, 650);
  }

  // particle system for jump & hurt
  function spawnJumpParticles(){
    for (let i=0;i<6;i++){
      state.particles.push({
        x: player.x + player.w/2 + (Math.random()*20-10),
        y: player.y + player.h,
        vx: (Math.random()*2-1)*0.9, vy: -Math.random()*2 - 1.2,
        life: 400 + Math.random()*200, size: 4 + Math.random()*4, color: 'rgba(40,40,40,0.18)'
      });
    }
  }
  function spawnHurtParticles(){
    for (let i=0;i<14;i++){
      state.particles.push({
        x: player.x + player.w/2 + (Math.random()*40-20),
        y: player.y + player.h/2 + (Math.random()*20-10),
        vx: (Math.random()*2-1)*2, vy: (Math.random()*2-1)*2,
        life: 600 + Math.random()*400, size: 3 + Math.random()*5, color: 'rgba(240,80,80,0.9)'
      });
    }
  }
  function updateParticles(dt){
    const now = Date.now();
    for (let i=state.particles.length-1;i>=0;i--){
      const p = state.particles[i];
      p.x += p.vx * (dt/16);
      p.y += p.vy * (dt/16);
      p.vy += 0.12 * (dt/16);
      p.life -= dt;
      if (p.life <= 0) state.particles.splice(i,1);
    }
  }
  function drawParticles(){
    for (const p of state.particles){
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.ellipse(p.x - state.camX, p.y, p.size, p.size*0.6, 0, 0, Math.PI*2);
      ctx.fill();
    }
  }

  // drawing helpers
  function starPath(r){
    ctx.beginPath();
    for (let i=0;i<5;i++){
      const a1 = (Math.PI*2)*i/5 - Math.PI/2;
      const a2 = a1 + Math.PI/5;
      ctx.lineTo(Math.cos(a1)*r, Math.sin(a1)*r);
      ctx.lineTo(Math.cos(a2)*(r*0.45), Math.sin(a2)*(r*0.45));
    }
    ctx.closePath();
  }

  function drawBackground(){
    const g = ctx.createLinearGradient(0,0,0,BASE_H);
    g.addColorStop(0, PAL.bgTop);
    g.addColorStop(1, PAL.bgBottom);
    ctx.fillStyle = g; ctx.fillRect(0,0,BASE_W,BASE_H);
    for (let i=0;i<10;i++){
      const y = 40 + (i*36);
      ctx.fillStyle = `rgba(255,255,255,${0.06 + (i%3)*0.02})`;
      const o = -((state.camX*0.14) % 400) + i*160;
      ctx.fillRect(o, y, 260, 14);
    }
  }

  function drawGroundSections(){
    for (const g of staticPlatforms.filter(p=>p.h>=40)){
      const sx = g.x - state.camX;
      ctx.fillStyle = PAL.ground1; ctx.fillRect(sx, g.y, g.w, g.h);
      ctx.fillStyle = PAL.ground2;
      for (let i=0;i<g.w;i+=28) ctx.fillRect(sx+i, g.y+g.h-28, 24, 28);
    }
    for (const p of staticPlatforms.filter(p=>p.h<40)){
      const sx = p.x - state.camX;
      ctx.fillStyle = PAL.block; ctx.fillRect(sx, p.y, p.w, p.h);
      ctx.strokeStyle = PAL.blockEdge; ctx.lineWidth = 2; ctx.strokeRect(sx+0.5, p.y+0.5, p.w-1, p.h-1);
    }
  }

  function drawMovingPlatforms(){
    for (const p of movingPlatforms){
      const sx = p.x - state.camX;
      ctx.fillStyle = '#ffd1dc'; ctx.fillRect(sx, p.y, p.w, p.h);
      ctx.strokeStyle = '#ff8aa0'; ctx.lineWidth = 2; ctx.strokeRect(sx+0.5, p.y+0.5, p.w-1, p.h-1);
    }
  }

  function drawSpikePits(){
    for (const pit of spikePits){
      const sx = pit.x - state.camX;
      // draw rim
      ctx.fillStyle = '#e0bca0'; ctx.fillRect(sx, groundY-10, pit.w, 12);
      ctx.fillStyle = 'rgba(0,0,0,0.08)'; ctx.fillRect(sx+6, groundY+2, pit.w-12, 8); // inside shadow
      // spikes inside (saw-tooth)
      const spikeH = 24;
      ctx.fillStyle = '#f27b7b'; ctx.strokeStyle = '#b33838';
      for (let x=0; x<pit.w; x+=18){
        ctx.beginPath();
        ctx.moveTo(sx+x, groundY+2);
        ctx.lineTo(sx+x+9, groundY+2 - spikeH);
        ctx.lineTo(sx+x+18, groundY+2);
        ctx.closePath(); ctx.fill(); ctx.stroke();
      }
    }
  }

  function drawStars(){
    for (const s of quizStars){
      if (!s.active) continue;
      const x = s.x - state.camX, y = s.y;
      ctx.save(); ctx.translate(x+9, y+9);
      ctx.rotate((Date.now()/450) % (Math.PI*2));
      ctx.beginPath(); ctx.arc(0,0,14,0,Math.PI*2);
      ctx.fillStyle = 'rgba(255,220,90,0.12)'; ctx.fill();
      ctx.restore();
      ctx.save(); ctx.translate(x+9, y+9); ctx.rotate((Date.now()/300) % (Math.PI*2));
      ctx.fillStyle = PAL.star; ctx.strokeStyle = PAL.starEdge; ctx.lineWidth = 2; starPath(9); ctx.fill(); ctx.stroke();
      ctx.restore();
    }
  }

  function drawEnemies(){
    for (const m of enemies){
      const x = m.x - state.camX, y = m.y;
      ctx.fillStyle = PAL.enemy; ctx.fillRect(x, y, m.w, m.h);
      ctx.strokeStyle = PAL.enemyEdge; ctx.lineWidth = 2; ctx.strokeRect(x+0.5, y+0.5, m.w-1, m.h-1);
      ctx.fillStyle = '#fff'; ctx.fillRect(x+6, y+8, 6, 6); ctx.fillRect(x+m.w-12, y+8, 6, 6);
    }
  }

  function drawBarriers(){
    for (let i=0;i<barriers.length;i++){
      const b = barriers[i]; const sx = b.x - state.camX;
      if (!b.opened){
        ctx.fillStyle = 'rgba(255,200,110,0.95)'; ctx.fillRect(sx,b.y,b.w,b.h);
        ctx.strokeStyle = '#d49b00'; ctx.lineWidth = 2; ctx.strokeRect(sx+0.5,b.y+0.5,b.w-1,b.h-1);
        ctx.fillStyle = '#222'; ctx.font = '600 12px Poppins'; ctx.fillText(`Butuh ${b.need}`, sx-6, 28);
      } else {
        ctx.strokeStyle = 'rgba(255,220,150,0.9)'; ctx.setLineDash([6,6]); ctx.strokeRect(sx+0.5,b.y+0.5,b.w-1,b.h-1); ctx.setLineDash([]);
      }
    }
  }

  function drawGoal(){
    const gx = goal.x - state.camX;
    ctx.fillStyle = '#38c46b'; ctx.fillRect(gx, goal.y, goal.w, goal.h);
    ctx.fillStyle = '#7bff8b'; ctx.beginPath();
    ctx.moveTo(gx + goal.w, goal.y+10); ctx.lineTo(gx + goal.w + 36, goal.y+24); ctx.lineTo(gx + goal.w, goal.y+38);
    ctx.closePath(); ctx.fill();
  }

  function drawPlayer(){
    const x = Math.floor(player.x - state.camX);
    const y = Math.floor(player.y);
    ctx.fillStyle = PAL.player; ctx.fillRect(x, y, player.w, player.h);
    ctx.strokeStyle = PAL.playerEdge; ctx.lineWidth = 2; ctx.strokeRect(x+0.5, y+0.5, player.w-1, player.h-1);
    ctx.fillStyle = '#fff';
    const eyeX = player.facing === 1 ? x + player.w - 10 : x + 6;
    ctx.fillRect(eyeX, y + 12, 4, 4);
  }

  function currentStageIdx(){
    for (let i=0;i<STAGE_BOUNDS.length;i++){
      const b = STAGE_BOUNDS[i];
      if (player.x >= b.start && player.x < b.end) return i;
    }
    return STAGE_BOUNDS.length - 1;
  }

  function drawHUD(){
    const sIdx = currentStageIdx();
    const need = barriers[sIdx].need;
    const ok = state.stageAnswered[sIdx] || 0;
    const found = quizStars.filter(st=>st.stage===sIdx && !st.active).length;
    // HUD background
    ctx.fillStyle = 'rgba(255,255,255,0.95)'; ctx.fillRect(8,8, 520, 72);
    ctx.fillStyle = PAL.text; ctx.font = '700 16px Poppins'; ctx.fillText('EduBros ‚Äî Star Hunt Quiz', 28, 30);
    ctx.font = '12px Poppins'; ctx.fillStyle = '#444';
    ctx.fillText(`Stage ${sIdx+1}: Terjawab ${ok}/${need}  ‚Ä¢  ‚≠ê ditemukan ${found}/${STARS_PER_STAGE}`, 28, 48);
    // lives
    ctx.fillStyle = '#ff6b6b'; ctx.font='700 14px Poppins'; ctx.fillText('‚ù§ '+Math.max(0,state.lives+1), 28, 66); // display lives as 3,2,1
    // toast
    if (state.toast){
      if (Date.now() < state.toast.until){
        ctx.save(); ctx.globalAlpha = 0.96; ctx.font = '600 14px Poppins'; ctx.textAlign = 'center'; ctx.fillStyle = '#222';
        ctx.fillText(state.toast.msg, BASE_W/2, 36); ctx.restore();
      } else state.toast = null;
    }
  }

  // win overlay & unanswered
  function showWinOverlay(){
    const totalSolved = state.correct.size;
    const totalWrong = state.wrong.size;
    const assigned = Array.from(state.usedQuizIndices);
    const unanswered = assigned.filter(i => !state.correct.has(i) && !state.wrong.has(i));
    const winStats = document.getElementById('winStats');
    winStats.innerHTML = `<div style="font-weight:700;color:#25303d">${totalSolved} benar ‚Ä¢ ${totalWrong} salah ‚Ä¢ ${unanswered.length} belum terjawab</div>`;
    const listEl = document.getElementById('unansweredList'); listEl.innerHTML = '';
    if (unanswered.length === 0){ listEl.textContent = 'Tidak ada ‚Äî semua soal sudah dicoba.'; } else {
      unanswered.forEach(idx=>{ const item = document.createElement('div'); item.style.padding='8px'; item.style.borderBottom='1px solid rgba(37,48,61,0.06)'; item.textContent = QUIZ[idx].q; listEl.appendChild(item); });
    }
    toggleOverlay('win', true);
  }

  // main loop
  let lastTime = performance.now();
  let rafId = 0;
  function loop(now=performance.now()){
    const dt = Math.min(40, now - lastTime);
    lastTime = now;
    if (state.scene === 'play'){
      const paused = !!state.pendingQuestion;
      if (!paused){
        handleInput();
        updateMovingPlatforms();
        player.x += player.vx;
        collideWorldX([...staticPlatforms, ...movingPlatforms, ...barriers.filter(b=>!b.opened)]);
        player.y += player.vy;
        player.onGround = false;
        collideWorldY([...staticPlatforms, ...movingPlatforms, ...barriers.filter(b=>!b.opened)]);
        carryWithMovingPlatform();
        player.x = clamp(player.x, 0, WORLD_END_X);
        player.y = Math.min(player.y, 2000);
        state.camX = clamp(player.x - BASE_W/2 + player.w/2, 0, Math.max(0, WORLD_END_X - BASE_W));
        updateEnemies();
        checkSpikePits();
        checkPitFall();
        collectQuizStars();
        checkBarriersOpenByProgress();
        checkWin();
      }
    }

    // draw
    ctx.clearRect(0,0,BASE_W,BASE_H);
    // camera shake effect
    if (Date.now() < state.shakeUntil){
      const s = (Math.random()*6 - 3);
      ctx.save(); ctx.translate(s, 0);
      drawScene(dt);
      ctx.restore();
    } else {
      drawScene(dt);
    }

    updateParticles(dt);
    rafId = requestAnimationFrame(loop);
  }

  function drawScene(dt){
    drawBackground();
    drawGroundSections();
    drawMovingPlatforms();
    drawSpikePits();
    drawStars();
    drawEnemies();
    drawBarriers();
    drawGoal();
    drawPlayer();
    drawParticles();
    drawHUD();
  }

  // overlay utility
  function toggleOverlay(id, show=true){
    const el = document.getElementById(id);
    if (!el) return false;
    el.style.display = show ? 'flex' : 'none';
    if (id !== 'loading'){
      if (show) { state.sceneOverlay = id; } else { state.sceneOverlay = null; }
    }
    return true;
  }

  // buttons wiring
  document.getElementById('startBtn').onclick = showLoading;
  document.getElementById('howBtn').onclick = ()=> toggleOverlay('how', true);
  document.getElementById('playAgainBtn').onclick = ()=> { toggleOverlay('win', false); toggleOverlay('menu', false); startGame(); };
  document.getElementById('reviewBtn').onclick = ()=> {
    const assigned = Array.from(state.usedQuizIndices);
    const unanswered = assigned.filter(i => !state.correct.has(i) && !state.wrong.has(i));
    toggleOverlay('win', false);
    if (unanswered.length === 0){ toast('Tidak ada soal belum terjawab.'); startGame(); return; }
    const idx = unanswered[0];
    state.pendingQuestion = {...QUIZ[idx], idx: idx, stage: null};
    showQuiz(state.pendingQuestion);
  };
  document.getElementById('retryBtn').onclick = ()=> { toggleOverlay('gameOver', false); startGame(); };
  document.getElementById('toMenuBtn').onclick = ()=> { toggleOverlay('gameOver', false); toggleOverlay('menu', true); };

  // loading & start
  function showLoading(){
    toggleOverlay('menu', false);
    toggleOverlay('loading', true);
    const prog = document.getElementById('prog');
    let v = 0;
    const t = setInterval(()=>{
      v += Math.random()*16 + 8;
      prog.value = Math.min(100, v);
      if (v >= 100){
        clearInterval(t);
        toggleOverlay('loading', false);
        startGame();
      }
    }, 140);
  }

  function startGame(){
    state.scene = 'play';
    state.camX = 0;
    state.lives = 2; // display shows lives+1, so set 2 => shows 3 hearts initially
    state.checkpointX = 60;
    state.correct.clear(); state.wrong.clear();
    state.pendingQuestion = null; state.pendingStar = null; state.quizCooldownUntil = 0; state.toast = null; state.particles = [];
    player.x = 60; player.y = groundY-40; player.vx = 0; player.vy = 0; player.onGround = false;
    barriers.forEach(b=> b.opened = false);
    genStarsForStages();
    lastTime = performance.now();
    loop();
  }

  // quiz mechanics & UI handled earlier (showQuiz/answerQuestion)

  // initial setup
  genStarsForStages();
  resizeCanvas();

  // small global exposure
  window.toggleOverlay = toggleOverlay;

  // helper: ensure jump key won't be held across overlay close - track keydown/up
  window.addEventListener('keyup', e => { if (e.key === ' ' || e.key === 'Spacebar') jumpHeld = false; });
  window.addEventListener('keydown', e => { if (e.key === ' ' || e.key === 'Spacebar') jumpHeld = true; });

  // small helper functions used earlier (clamp defined above)

  // work-around: ensure audio ctx resumed on first user interaction
  function resumeAudio() { try{ if (audioCtx.state === 'suspended') audioCtx.resume(); }catch(e){} window.removeEventListener('pointerdown', resumeAudio); }
  window.addEventListener('pointerdown', resumeAudio);

  // expose some debug actions (optional)
  // window.startGame = startGame;

})();
</script>
</body>
</html>
