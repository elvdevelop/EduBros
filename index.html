<!doctype html>
<html lang="id">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1, viewport-fit=cover" />
<title>EduBros — Star Hunt Quiz (Responsive)</title>
<style>
  :root{
    --bg:#0e0f13; --card:#121420; --muted:#aeb6ca; --accent:#5b75ff;
    --glass: rgba(17,19,27,0.85);
  }
  *{box-sizing:border-box}
  html,body{height:100%; margin:0; background:var(--bg); color:#e7ecf3; font-family:system-ui, Arial, sans-serif; -webkit-font-smoothing:antialiased}
  #wrap{display:flex;align-items:center;justify-content:center;min-height:100vh;padding:env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left)}
  /* canvas responsive — width limited but scalable */
  .canvas-wrap{width:min(1000px, calc(100vw - 24px)); max-width:100%; aspect-ratio:16/9; background:#1a1d28; border:2px solid #2c3246; border-radius:8px; overflow:hidden; display:flex; align-items:center; justify-content:center}
  canvas{width:100%; height:100%; display:block; image-rendering:pixelated}

  /* overlays */
  .overlay{position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,.55); z-index:60; padding:16px}
  .card{width:min(760px,96vw); background:var(--card); border-radius:12px; padding:16px; border:2px solid #2c3246; box-shadow:0 12px 40px rgba(0,0,0,.6)}
  .title{font-weight:700}
  .muted{color:var(--muted); font-size:14px}
  .btn{display:inline-block;padding:10px 14px;border-radius:10px;border:2px solid #3a4363;background:#20253a;color:inherit;cursor:pointer}
  .btn.primary{background:linear-gradient(180deg,var(--accent),#3040a0);border-color:#3040a0}
  .btnbar{display:flex;gap:10px;flex-wrap:wrap;justify-content:center;margin-top:12px}
  .center{text-align:center}

  /* small HUD below canvas for mobile */
  #touch{position:fixed;left:env(safe-area-inset-left);right:env(safe-area-inset-right);bottom:env(safe-area-inset-bottom);display:flex;justify-content:space-between;padding:8px;gap:8px;pointer-events:none;z-index:50}
  .pad{pointer-events:auto;display:flex;gap:8px}
  .pad .key,.pad .jump{width:64px;height:64px;border-radius:12px;border:2px solid #3a4363;background:rgba(32,37,58,.68);display:flex;align-items:center;justify-content:center;font-weight:700;user-select:none}
  .pad .jump{width:88px}
  .pad .key:active, .pad .jump:active{background:#3a4363bb}

  /* Styling for quiz choices (inside overlay) */
  #qChoices{display:flex;flex-direction:column;gap:8px}
  #qChoices button{justify-content:flex-start}

  /* win overlay list */
  #unansweredList{max-height:220px; overflow:auto; padding:8px; border-radius:8px; background:rgba(255,255,255,.03); margin-top:8px}

  /* responsive tweaks */
  @media (min-width:800px){
    .btnbar{justify-content:flex-start}
  }
</style>
</head>
<body>
  <div id="wrap">
    <div class="canvas-wrap" role="application" aria-label="EduBros Game Area">
      <canvas id="game" aria-label="EduBros Game Canvas"></canvas>
    </div>
  </div>

  <!-- Overlays -->
  <div id="menu" class="overlay" style="display:flex" role="dialog" aria-modal="true">
    <div class="card center">
      <div class="title" style="font-size:44px">EduBros</div>
      <div class="muted" style="margin-top:6px">Star-Hunt Quiz — Platformer & Kuis</div>
      <p style="text-align:left;margin-top:12px">Aturan singkat:
      <ul style="text-align:left">
        <li>Kontrol: ← → bergerak, ↑ / Spasi = lompat.</li>
        <li>Per stage ada 8 bintang; sebagian berisi soal, sebagian kosong.</li>
        <li>Jawab benar 3 (atau sesuai HUD) untuk membuka gerbang.</li>
      </ul>
      </p>
      <div class="btnbar" style="margin-top:12px">
        <button id="startBtn" class="btn primary">Mulai</button>
        <button id="howBtn" class="btn">Cara Main</button>
      </div>
      <div class="muted" style="margin-top:10px">Versi perbaikan — responsif & pembelajaran</div>
    </div>
  </div>

  <div id="how" class="overlay" role="dialog" aria-modal="true">
    <div class="card">
      <div class="title" style="font-size:20px">Cara Main</div>
      <ol style="margin-top:8px">
        <li>Kumpulkan bintang — beberapa berisi soal.</li>
        <li>Kuis mem-pause game. Pilih jawaban, benar/salah tercatat.</li>
        <li>Salah akan dihitung sebagai <b>salah</b> dan bintang akan hilang.</li>
        <li>Soal yang tidak pernah dijawab (skip/tidak sempat) akan ditampilkan di akhir.</li>
      </ol>
      <div class="btnbar" style="margin-top:12px">
        <button class="btn" onclick="toggleOverlay('how',false)">Tutup</button>
      </div>
    </div>
  </div>

  <div id="quiz" class="overlay" role="dialog" aria-modal="true">
    <div class="card">
      <div class="title" id="qTitle" style="font-size:18px">Pertanyaan</div>
      <div id="qText" style="margin-top:8px"></div>
      <div id="qChoices" style="margin-top:12px"></div>
      <div id="qFeedback" class="muted" style="margin-top:8px"></div>
      <div class="btnbar" style="margin-top:12px">
        <button id="skipBtn" class="btn" title="Tutup kuis, bintang tetap ada">Lewati</button>
      </div>
    </div>
  </div>

  <div id="loading" class="overlay" role="dialog" aria-modal="true">
    <div class="card center">
      <div class="title" style="font-size:22px">Memuat…</div>
      <div class="muted" style="margin-top:8px">Menyiapkan dunia belajar</div>
      <div style="margin-top:12px"><progress id="prog" max="100" value="0" style="width:80%;height:16px"></progress></div>
    </div>
  </div>

  <div id="win" class="overlay" role="dialog" aria-modal="true">
    <div class="card">
      <div class="title" style="font-size:20px">Permainan Selesai</div>
      <div id="winStats" style="margin-top:10px"></div>
      <div id="unansweredSection" style="margin-top:8px">
        <div class="muted">Soal yang tidak terjawab:</div>
        <div id="unansweredList"></div>
      </div>
      <div class="btnbar" style="margin-top:12px">
        <button id="playAgainBtn" class="btn primary">Main Lagi</button>
        <button id="reviewBtn" class="btn">Ulangi Soal Belum Terjawab</button>
      </div>
    </div>
  </div>

  <!-- Touch controls (visible on touch devices) -->
  <div id="touch" aria-hidden="false">
    <div class="pad">
      <div class="key" data-k="ArrowLeft">←</div>
      <div class="key" data-k="ArrowRight">→</div>
    </div>
    <div class="pad">
      <div class="jump" data-k="Space">Lompat</div>
    </div>
  </div>

<script>
(() => {
  'use strict';

  // --- BASE logical resolution (draw using these coordinates) ---
  const BASE_W = 960, BASE_H = 540;

  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', {alpha:false});

  // game constants (based on BASE_H)
  const groundY = BASE_H - 60;
  const WORLD_END_X = 9800;

  // palettes
  const PAL = {
    bgSky:'#1a1d28', bgFar:'#151826',
    ground1:'#2e2a3f', ground2:'#3a3553',
    block:'#4c4673', blockEdge:'#767bb6',
    star:'#ffd95a', starEdge:'#ffb700',
    player:'#7be0ff', playerEdge:'#2dc0ff',
    enemy:'#ff7b7b', enemyEdge:'#ff3b3b',
    text:'#e7ecf3'
  };

  // state
  const state = {
    scene:'menu', camX:0,
    keys:{}, touch:{left:false,right:false},
    gravity:0.7, friction:0.72,
    lives:3, checkpointX:60,
    correct: new Set(), wrong: new Set(), // indices of quiz answered correct / wrong
    usedQuizIndices: new Set(), // quiz indices assigned to stars
    stageCorrect:[], // will init later
    pendingQuestion: null, pendingStar: null,
    quizCooldownUntil:0,
    toast: null
  };

  // level geometry (will use groundY)
  const barriers = [
    {x:2200, y:0, w:20, h:groundY, opened:false, need:3},
    {x:4600, y:0, w:20, h:groundY, opened:false, need:3},
    {x:7000, y:0, w:20, h:groundY, opened:false, need:3},
    {x:9400, y:0, w:20, h:groundY, opened:false, need:4}
  ];
  const STAGE_COUNT = barriers.length;
  const STAGE_BOUNDS = (function mkBounds(){
    const B = [];
    for (let i=0;i<STAGE_COUNT;i++){
      const start = i===0 ? 0 : (barriers[i-1].x + barriers[i-1].w);
      const end   = barriers[i].x;
      B.push({start, end});
    }
    return B;
  })();

  // Platforms
  const staticPlatforms = [
    {x:0,    y:groundY, w:2200, h:60},
    {x:2220, y:groundY, w:2380, h:60},
    {x:4620, y:groundY, w:2380, h:60},
    {x:7020, y:groundY, w:2380, h:60},
    {x:9420, y:groundY, w:260,  h:60},

    {x:260,  y:groundY-110, w:140, h:20},
    {x:520,  y:groundY-170, w:140, h:20},
    {x:820,  y:groundY-130, w:160, h:20},
    {x:1300, y:groundY-190, w:160, h:20},

    {x:2400, y:groundY-150, w:160, h:20},
    {x:2760, y:groundY-210, w:160, h:20},
    {x:3160, y:groundY-150, w:160, h:20},
    {x:3540, y:groundY-210, w:160, h:20},

    {x:4800, y:groundY-150, w:160, h:20},
    {x:5160, y:groundY-210, w:160, h:20},
    {x:5560, y:groundY-150, w:160, h:20},
    {x:5940, y:groundY-210, w:160, h:20},

    {x:7200, y:groundY-150, w:160, h:20},
    {x:7560, y:groundY-210, w:160, h:20},
    {x:7960, y:groundY-150, w:160, h:20},
    {x:8340, y:groundY-210, w:160, h:20},
  ];

  const movingPlatforms = [
    {x:2000,y:groundY-180,w:160,h:20, dir:1, speed:0.9, min:1900, max:2120, dx:0},
    {x:4380,y:groundY-200,w:160,h:20, dir:-1,speed:0.8, min:4240, max:4500, dx:0},
    {x:6780,y:groundY-180,w:160,h:20, dir:1, speed:1.0, min:6660, max:6920, dx:0},
    {x:9180,y:groundY-200,w:160,h:20, dir:-1,speed:0.7, min:9040, max:9320, dx:0}
  ];

  const spikes = [
    {x:1700,y:groundY-20,w:120,h:20},
    {x:4100,y:groundY-20,w:120,h:20},
    {x:6500,y:groundY-20,w:120,h:20},
    {x:8900,y:groundY-20,w:120,h:20}
  ];

  const enemies = [
    {x:840,  y:groundY-28, w:28, h:28, dir:-1, speed:1.1, min:760,  max:920},
    {x:3050, y:groundY-28, w:28, h:28, dir:1,  speed:1.2, min:2960, max:3160},
    {x:5450, y:groundY-28, w:28, h:28, dir:-1, speed:1.0, min:5360, max:5560},
    {x:7850, y:groundY-28, w:28, h:28, dir:1,  speed:1.1, min:7760, max:7960}
  ];

  const goal = {x:WORLD_END_X-120, y:groundY-120, w:18, h:120};

  // player
  const player = { x:60, y:groundY-40, w:26, h:36, vx:0, vy:0, onGround:false, facing:1 };

  // quiz bank
  const QUIZ = [
    {q:"Hasil dari 16 ½ × 27 ⅔ adalah …", choices:["24","144","12","36"], correct:3, tag:"Aritmetika"},
    {q:"Deret aritmetika dimulai dari 6 dan beda 7. Suku ke-10 adalah …", choices:["62","63","64","65"], correct:2, tag:"Barisan"},
    {q:"Luas trapesium sisi sejajar 12 cm dan 20 cm, tinggi 9 cm adalah …", choices:["96 cm²","108 cm²","120 cm²","144 cm²"], correct:1, tag:"Bangun Datar"},
    {q:"Pola segitiga: 1, 3, 6, 10, … Jumlah titik pada susunan ke-7 adalah …", choices:["28","27","21","36"], correct:0, tag:"Pola Bilangan"},
    {q:"Jika f(x)=2x+7 dan g(x)=x²−2x+1, maka (f∘g)(−1) = …", choices:["9","11","13","15"], correct:3, tag:"Fungsi"},
    {q:"Diketahui f(x)=2x+8 dan g(x)=4x−8. Nilai (f∘g)(x) adalah …", choices:["8x−16","8x−8","6x−8","4x−8"], correct:1, tag:"Fungsi"},
    {q:"Jika f(x)=3x+8 dan (f∘g)(x)=3x−1, maka g(10) = …", choices:["5","6","7","8"], correct:2, tag:"Fungsi"},
    {q:"Diketahui f(x)=2x+5 dan g(x)=x−1. Jika (f∘g)(a)=13, maka a = …", choices:["6","3","4","5"], correct:3, tag:"Fungsi"},
    {q:"f(x)=3x+6. Nilai f⁻¹(15) adalah …", choices:["3","4","5","6"], correct:0, tag:"Fungsi Invers"},
    {q:"Di Rejeki: buku Rp8.000, penghapus Rp3.500, bolpoin Rp6.500. Di Makmur: buku Rp9.000, penghapus Rp3.000, bolpoin Rp6.000. Pernyataan benar adalah …",
     choices:[
       "Harga buku tulis di Rejeki lebih mahal dari Makmur.",
       "Harga buku tulis di Rejeki lebih murah dari Makmur.",
       "Harga penghapus di Rejeki sama dengan di Makmur.",
       "Harga penghapus di Rejeki lebih murah dari Makmur.",
       "Harga bolpoin di Rejeki lebih murah dari Makmur."
     ], correct:1, tag:"Numerasi"},
    {q:"Rudi punya 120 kelereng. Setelah pembagian seperti soal, selisih paling banyak dengan temannya adalah …", choices:["23","22","20","14","4"], correct:2, tag:"Persentase"},
    {q:"Toko membeli 30 buku @Rp40.000 dan ongkir Rp150.000. Dijual @Rp50.000. Keuntungan total adalah …", choices:["Rp200.000","Rp250.000","Rp300.000","Rp350.000"], correct:2, tag:"Keuangan"},
    {q:"Di kelas ada 12 laki-laki dan 8 perempuan. Peluang terpilih perempuan adalah …", choices:["1/2","2/5","3/5","1/4"], correct:1, tag:"Peluang"},
    {q:"Dadu 6 sisi dilempar sekali. (a) genap, (b) ganjil > 3. Peluangnya …", choices:["1/2 dan 1/6","1/3 dan 1/2","1/2 dan 1/3","2/3 dan 1/6"], correct:0, tag:"Peluang"},
    {q:"Stok beras 75 kg. Dijual tiap hari bertambah 5 kg, mulai 5 kg hari pertama. Berapa hari sampai habis?", choices:["5 hari","8 hari","10 hari","12 hari"], correct:0, tag:"Barisan"},
    {q:"Menabung bulan pertama Rp250.000, tiap bulan naik Rp50.000. Total 6 bulan adalah …", choices:["Rp2.250.000","Rp2.400.000","Rp2.550.000","Rp2.700.000"], correct:0, tag:"Barisan"},
    {q:"Bakteri menjadi 3× tiap 30 menit. Jika awal 2 bakteri, setelah pembelahan ke-4 jumlahnya …", choices:["54","81","108","162"], correct:3, tag:"Pertumbuhan"},
    {q:"Modal Rp1.000.000 bertambah 20% tiap bulan. Nilai modal pada bulan ke-3 adalah …", choices:["Rp1.440.000","Rp1.728.000","Rp2.000.000","Rp2.400.000"], correct:1, tag:"Pertumbuhan"},
    {q:"(2a + 3b − 4) + (a − 3b + 2) = …", choices:["3a − 2","a + b − 2","3a + 2b − 2","2a − 2"], correct:0, tag:"Aljabar"},
    {q:"Sederhanakan: 4(3a + 2) − 3(6a − 5) = …", choices:["6a + 23","−6a + 23","−12a − 7","−6a − 23"], correct:1, tag:"Aljabar"}
  ];

  // stars
  const STARS_PER_STAGE = 8;
  let quizStars = []; // {x,y,w,h,active,stage, quizIndex, locked}

  // random helpers
  function randInt(n){ return (Math.random()*n)|0; }
  function shuffle(arr){
    const a = arr.slice();
    for (let i=a.length-1;i>0;i--){ const j = randInt(i+1); [a[i],a[j]] = [a[j],a[i]]; }
    return a;
  }

  // --- assign quiz indices to stars (unique across run if possible) ---
  function genStarsForStages(){
    quizStars = [];
    state.usedQuizIndices.clear();
    state.stageCorrect = Array(STAGE_COUNT).fill(0);

    // create a cyclic shuffled pool of quiz indices so we can allocate many
    const allIdx = Array.from({length:QUIZ.length}, (_,i)=>i);
    let pool = shuffle(allIdx);
    let poolPos = 0;
    function nextQuizIndex(){
      if (poolPos >= pool.length){ pool = shuffle(allIdx); poolPos = 0; } // repeat if exhausted
      const v = pool[poolPos++]; state.usedQuizIndices.add(v); return v;
    }

    for (let s=0;s<STAGE_COUNT;s++){
      const {start, end} = STAGE_BOUNDS[s];
      const left = start + 140, right = end - 140;
      const span = Math.max(200, right - left);
      const need = barriers[s].need;
      const target = Math.round(STARS_PER_STAGE * 0.6);
      const quizCount = Math.min(STARS_PER_STAGE, Math.max(need + 1, target));
      // choose which star positions in this stage are quiz stars
      const quizSlots = new Set(shuffle(Array.from({length:STARS_PER_STAGE},(_,i)=>i)).slice(0, quizCount));

      for (let k=0;k<STARS_PER_STAGE;k++){
        const base = left + (k+0.5) * (span / STARS_PER_STAGE);
        const jitter = (Math.random()*160 - 80);
        const x = clamp(Math.floor(base + jitter), left+40, right-40);
        const yOptions = [groundY-30, groundY-90, groundY-150, groundY-210];
        const y = yOptions[randInt(yOptions.length)];
        if (quizSlots.has(k)){
          quizStars.push({x,y,w:18,h:18, active:true, stage:s, locked:false, quiz:true, quizIndex: nextQuizIndex()});
        } else {
          quizStars.push({x,y,w:18,h:18, active:true, stage:s, locked:false, quiz:false, quizIndex:null});
        }
      }
    }
  }

  // helper clamp & overlap
  function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }
  function rectsOverlap(a,b){ return a.x < b.x+b.w && a.x+a.w > b.x && a.y < b.y+b.h && a.y+a.h > b.y; }

  // --- responsive canvas scaling (handles DPR) ---
  let SCALE = 1;
  function resizeCanvas(){
    // CSS size (keep aspect ratio 16:9)
    const wrap = document.querySelector('.canvas-wrap');
    const cssW = Math.max(320, Math.min(1000, wrap.clientWidth));
    const cssH = Math.round(cssW * (BASE_H / BASE_W));
    // device pixel ratio
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    // logical canvas pixel size
    canvas.style.width = cssW + 'px';
    canvas.style.height = cssH + 'px';
    canvas.width = Math.round(cssW * dpr);
    canvas.height = Math.round(cssH * dpr);
    // scale transform so drawing code uses BASE_W x BASE_H coordinates
    SCALE = cssW / BASE_W;
    ctx.setTransform(dpr * SCALE, 0, 0, dpr * SCALE, 0, 0);
  }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  // --- input handling ---
  const keyMap = { ' ': 'Space', Spacebar:'Space', Left:'ArrowLeft', Right:'ArrowRight', Up:'ArrowUp' };
  function normKey(k){ return keyMap[k] || k; }
  window.addEventListener('keydown', e=>{
    const k = normKey(e.key);
    if (['ArrowLeft','ArrowRight','ArrowUp','Space'].includes(k)) e.preventDefault();
    state.keys[k] = true;
  }, {passive:false});
  window.addEventListener('keyup', e=> { const k = normKey(e.key); state.keys[k] = false; }, {passive:false});

  // touch buttons
  const tpanel = document.getElementById('touch');
  try { if (!(window.matchMedia && window.matchMedia('(pointer: coarse)').matches)) tpanel.style.display = 'none'; } catch(e){}
  tpanel.addEventListener('touchstart', e=>{
    const t = e.target.closest('[data-k]');
    if (t){ e.preventDefault(); pressKey(t.dataset.k, true); }
  }, {passive:false});
  const endTouch = e=>{
    const t = e.target.closest('[data-k]');
    if (t){ e.preventDefault(); pressKey(t.dataset.k, false); }
  };
  tpanel.addEventListener('touchend', endTouch, {passive:false});
  tpanel.addEventListener('touchcancel', endTouch, {passive:false});
  function pressKey(k, down){
    if (k === 'ArrowLeft') state.touch.left = down;
    if (k === 'ArrowRight') state.touch.right = down;
    if (k === 'Space' && down) jump();
  }

  // --- start / reset ---
  function showLoading(){
    toggleOverlay('menu', false);
    toggleOverlay('loading', true);
    const prog = document.getElementById('prog');
    let v = 0;
    const t = setInterval(()=>{
      v += Math.random()*18 + 6;
      prog.value = Math.min(100, v);
      if (v >= 100){
        clearInterval(t);
        toggleOverlay('loading', false);
        startGame();
      }
    }, 140);
  }

  function startGame(){
    // reset
    state.scene = 'play';
    state.camX = 0;
    state.lives = 3;
    state.checkpointX = 60;
    state.correct.clear(); state.wrong.clear();
    state.pendingQuestion = null; state.pendingStar = null; state.quizCooldownUntil = 0; state.toast = null;
    player.x = 60; player.y = groundY-40; player.vx = 0; player.vy = 0; player.onGround = false;
    barriers.forEach(b=> b.opened = false);
    genStarsForStages();
    loop();
  }

  // physics helpers
  function jump(){ if (player.onGround){ player.vy = -14; player.onGround = false; } }

  function updateMovingPlatforms(){
    for (const p of movingPlatforms){
      const dx = p.speed * p.dir;
      p.x += dx;
      if (p.x < p.min){ p.x = p.min; p.dir = 1; }
      if (p.x + p.w > p.max){ p.x = p.max - p.w; p.dir = -1; }
      p.dx = dx;
    }
  }

  function carryWithMovingPlatform(){
    for (const p of movingPlatforms){
      const onTop = player.onGround &&
                    Math.abs((player.y + player.h) - p.y) < 1.5 &&
                    player.x + player.w > p.x && player.x < p.x + p.w;
      if (onTop){ player.x += (p.dx || 0); }
    }
  }

  function collideWorldX(objs){
    for (const o of objs) if (rectsOverlap(player,o)){
      if (player.vx > 0) player.x = o.x - player.w;
      else if (player.vx < 0) player.x = o.x + o.w;
      player.vx = 0;
    }
  }
  function collideWorldY(objs){
    for (const o of objs) if (rectsOverlap(player,o)){
      if (player.vy > 0){ player.y = o.y - player.h; player.vy = 0; player.onGround = true; }
      else if (player.vy < 0){ player.y = o.y + o.h; player.vy = 0; }
    }
  }

  // main gameplay functions
  function handleInput(){
    const left = state.keys['ArrowLeft'] || state.touch.left;
    const right = state.keys['ArrowRight'] || state.touch.right;
    const jumpKey = state.keys['ArrowUp'] || state.keys['Space'];

    if (left && !right){ player.vx -= 0.58; player.facing = -1; }
    if (right && !left){ player.vx += 0.58; player.facing = 1; }
    if (!left && !right){ player.vx *= state.friction; }
    player.vx = clamp(player.vx, -5.2, 5.2);

    if (jumpKey) jump();
  }

  function updateEnemies(){
    for (const m of enemies){
      m.x += m.speed * m.dir;
      if (m.x < m.min){ m.x = m.min; m.dir = 1; }
      if (m.x + m.w > m.max){ m.x = m.max - m.w; m.dir = -1; }
      if (rectsOverlap(player, m)){
        if (player.vy > 2){ player.vy = -9; m.min -= 6; m.max += 6; }
        else { die(); }
      }
    }
  }

  function die(){
    state.lives -= 1;
    if (state.lives < 0){ startGame(); return; }
    player.x = state.checkpointX; player.y = groundY-80; player.vx = 0; player.vy = 0;
    toast('Kamu kehilangan nyawa!', 1100);
  }

  function toast(msg, dur=1000){
    state.toast = {msg, until: Date.now() + dur};
  }

  // collect / trigger stars
  function collectQuizStars(){
    if (state.pendingQuestion || Date.now() < state.quizCooldownUntil) return;
    for (const s of quizStars){
      if (!s.active || s.locked) continue;
      if (rectsOverlap(player, s)){
        if (s.quiz){
          // show the question assigned to this star's quizIndex
          const qi = s.quizIndex;
          state.pendingStar = s;
          state.pendingQuestion = { ...QUIZ[qi], idx: qi, stage: s.stage };
          s.locked = true;
          showQuiz(state.pendingQuestion);
        } else {
          // empty star: disappear, small feedback
          s.active = false; s.locked = false;
          state.checkpointX = Math.max(state.checkpointX, player.x - 10);
          toast('Bintang kosong — cari yang lain!', 1100);
          state.quizCooldownUntil = Date.now() + 250;
        }
        break;
      }
    }
  }

  function checkSpikes(){ for (const s of spikes) if (rectsOverlap(player, s)) { die(); return; } }
  function checkPitFall(){ if (player.y > groundY + 160) { die(); } }

  function checkBarriersOpenByProgress(){
    for (let i=0;i<barriers.length;i++){
      const b = barriers[i];
      if (!b.opened && state.stageCorrect[i] >= b.need){ b.opened = true; }
    }
  }

  function checkWin(){ if (rectsOverlap(player, goal)) { state.scene = 'win'; showWinOverlay(); } }

  // --- QUIZ UI & logic ---
  function showQuiz(q){
    const qText = document.getElementById('qText');
    const qChoices = document.getElementById('qChoices');
    const qTitle = document.getElementById('qTitle');
    const qFeedback = document.getElementById('qFeedback');

    qTitle.textContent = KUIS • ${q.tag || 'Soal'};
    qText.textContent = q.q;
    qChoices.innerHTML = '';
    qFeedback.textContent = '';

    // build choices
    q.choices.forEach((c, idx)=>{
      const btn = document.createElement('button');
      btn.className = 'btn';
      btn.style.justifyContent = 'flex-start';
      btn.textContent = c;
      btn.onclick = ()=> answerQuestion(q, idx);
      qChoices.appendChild(btn);
    });

    document.getElementById('skipBtn').onclick = ()=>{
      toggleOverlay('quiz', false);
      // do not mark as wrong; allow revisit later
      if (state.pendingStar) state.pendingStar.locked = false;
      state.pendingQuestion = null;
      state.pendingStar = null;
      state.quizCooldownUntil = Date.now() + 800;
    };

    toggleOverlay('quiz', true);
    player.vx = 0;
  }

  function answerQuestion(q, idx){
    const qFeedback = document.getElementById('qFeedback');
    if (idx === q.correct){
      qFeedback.textContent = 'Benar!';
      state.correct.add(q.idx);
      if (state.pendingStar){
        state.pendingStar.active = false; state.pendingStar.locked = false;
        state.checkpointX = Math.max(state.checkpointX, player.x - 10);
        state.stageCorrect[q.stage] = Math.min(state.stageCorrect[q.stage] + 1, 99);
      }
      setTimeout(()=>{
        toggleOverlay('quiz', false);
        state.pendingQuestion = null; state.pendingStar = null;
        state.quizCooldownUntil = Date.now() + 600;
      }, 350);
    } else {
      // count as wrong (user requested)
      qFeedback.textContent = 'Salah — akan dihitung sebagai jawaban salah.';
      state.wrong.add(q.idx);
      // remove the star so it can't be retried
      if (state.pendingStar){
        state.pendingStar.active = false; state.pendingStar.locked = false;
      }
      setTimeout(()=>{
        toggleOverlay('quiz', false);
        state.pendingQuestion = null; state.pendingStar = null;
        state.quizCooldownUntil = Date.now() + 600;
      }, 550);
    }
  }

  // --- draw functions (use BASE_W / BASE_H coordinates) ---
  function starPath(r){
    ctx.beginPath();
    for (let i=0;i<5;i++){
      const a1 = (Math.PI*2)*i/5 - Math.PI/2;
      const a2 = a1 + Math.PI/5;
      ctx.lineTo(Math.cos(a1)*r, Math.sin(a1)*r);
      ctx.lineTo(Math.cos(a2)(r*0.45), Math.sin(a2)(r*0.45));
    }
    ctx.closePath();
  }

  function drawBackground(){
    ctx.fillStyle = PAL.bgSky; ctx.fillRect(0,0,BASE_W,BASE_H);
    ctx.fillStyle = PAL.bgFar;
    for (let i=0;i<8;i++){
      const y = BASE_H - 120 - i*28;
      const o1 = -((state.camX*0.20) % 300) + i*300;
      const o2 = -((state.camX*0.15) % 340) + i*340 + 120;
      ctx.fillRect(o1, y, 280, 10);
      ctx.fillRect(o2, y+18, 300, 8);
    }
  }

  function drawStaticPlatforms(){
    const segs = staticPlatforms.filter(p=>p.h >= 40);
    for (const g of segs){
      const sx = g.x - state.camX;
      ctx.fillStyle = PAL.ground1; ctx.fillRect(sx, g.y, g.w, g.h);
      ctx.fillStyle = PAL.ground2;
      for (let i=0;i<g.w;i+=24) ctx.fillRect(sx+i, g.y+g.h-24, 20, 24);
    }
    for (const p of staticPlatforms.filter(p=>p.h < 40)){
      const sx = p.x - state.camX;
      ctx.fillStyle = PAL.block; ctx.fillRect(sx, p.y, p.w, p.h);
      ctx.strokeStyle = PAL.blockEdge; ctx.lineWidth = 2; ctx.strokeRect(sx+0.5, p.y+0.5, p.w-1, p.h-1);
    }
  }

  function drawMovingPlatforms(){
    for (const p of movingPlatforms){
      const sx = p.x - state.camX;
      ctx.fillStyle = '#5a548a'; ctx.fillRect(sx, p.y, p.w, p.h);
      ctx.strokeStyle = '#9aa0ff'; ctx.lineWidth = 2; ctx.strokeRect(sx+0.5, p.y+0.5, p.w-1, p.h-1);
    }
  }

  function drawSpikes(){
    for (const s of spikes){
      const sx = s.x - state.camX;
      const step = 20;
      ctx.fillStyle = '#d04c4c'; ctx.strokeStyle = '#8e2222'; ctx.lineWidth = 1.5;
      for (let x=0; x<s.w; x+=step){
        ctx.beginPath();
        ctx.moveTo(sx+x, s.y+s.h);
        ctx.lineTo(sx+x+step/2, s.y);
        ctx.lineTo(sx+x+step, s.y+s.h);
        ctx.closePath(); ctx.fill(); ctx.stroke();
      }
    }
  }

  function drawStars(){
    for (const s of quizStars){
      if (!s.active) continue;
      const x = s.x - state.camX, y = s.y;
      ctx.save(); ctx.translate(x+9, y+9);
      ctx.rotate((Date.now()/450) % (Math.PI*2));
      ctx.fillStyle = PAL.star; ctx.strokeStyle = PAL.starEdge; ctx.lineWidth = 2;
      starPath(9); ctx.fill(); ctx.stroke(); ctx.restore();
    }
  }

  function drawEnemies(){
    for (const m of enemies){
      const x = m.x - state.camX, y = m.y;
      ctx.fillStyle = PAL.enemy; ctx.fillRect(x, y, m.w, m.h);
      ctx.strokeStyle = PAL.enemyEdge; ctx.lineWidth = 2; ctx.strokeRect(x+0.5, y+0.5, m.w-1, m.h-1);
      ctx.fillStyle = '#1a1d28'; ctx.fillRect(x+6, y+8, 6, 6); ctx.fillRect(x+m.w-12, y+8, 6, 6);
    }
  }

  function drawBarriers(){
    for (let i=0;i<barriers.length;i++){
      const b = barriers[i]; const sx = b.x - state.camX;
      if (!b.opened){
        ctx.fillStyle = '#ffcc66'; ctx.fillRect(sx,b.y,b.w,b.h);
        ctx.strokeStyle = '#d49b00'; ctx.lineWidth = 2; ctx.strokeRect(sx+0.5,b.y+0.5,b.w-1,b.h-1);
      } else {
        ctx.strokeStyle = '#ffe39b'; ctx.setLineDash([6,6]); ctx.strokeRect(sx+0.5,b.y+0.5,b.w-1,b.h-1); ctx.setLineDash([]);
      }
    }
  }

  function drawGoal(){
    const gx = goal.x - state.camX;
    ctx.fillStyle = '#38c46b'; ctx.fillRect(gx, goal.y, goal.w, goal.h);
    ctx.fillStyle = '#7bff8b'; ctx.beginPath();
    ctx.moveTo(gx + goal.w, goal.y+10); ctx.lineTo(gx + goal.w + 36, goal.y+24); ctx.lineTo(gx + goal.w, goal.y+38);
    ctx.closePath(); ctx.fill();
  }

  function drawPlayer(){
    const x = Math.floor(player.x - state.camX);
    const y = Math.floor(player.y);
    ctx.fillStyle = PAL.player; ctx.fillRect(x, y, player.w, player.h);
    ctx.strokeStyle = PAL.playerEdge; ctx.lineWidth = 2; ctx.strokeRect(x+0.5, y+0.5, player.w-1, player.h-1);
    ctx.fillStyle = '#1a1d28';
    const eyeX = player.facing === 1 ? x + player.w - 8 : x + 4;
    ctx.fillRect(eyeX, y + 10, 3, 3);
  }

  function currentStageIdx(){
    for (let i=0;i<STAGE_BOUNDS.length;i++){
      const b = STAGE_BOUNDS[i];
      if (player.x >= b.start && player.x < b.end) return i;
    }
    return STAGE_BOUNDS.length - 1;
  }

  function drawHUD(){
    const sIdx = currentStageIdx();
    const need = barriers[sIdx].need;
    const ok = state.stageCorrect[sIdx];
    const found = quizStars.filter(st=>st.stage===sIdx && !st.active).length;
    // background box
    ctx.fillStyle = '#11131bcc'; ctx.fillRect(8,8, 480, 72);
    ctx.fillStyle = PAL.text; ctx.font = 'bold 16px system-ui, Arial'; ctx.fillText('EduBros — Star-Hunt Quiz', 20, 28);
    ctx.font = '12px system-ui, Arial';
    ctx.fillText('Stage ' + (sIdx+1) + ': ✔ Benar ' + ok + '/' + need + '  •  ⭐ ditemukan ' + found + '/' + STARS_PER_STAGE, 20, 44);
    ctx.fillText('❤ ' + state.lives, 20, 60);

    if (state.toast){
      if (Date.now() < state.toast.until){
        ctx.save();
        ctx.globalAlpha = 0.95;
        ctx.font = 'bold 14px system-ui, Arial';
        ctx.textAlign = 'center';
        ctx.fillStyle = '#ffffff';
        ctx.fillText(state.toast.msg, BASE_W/2, 36);
        ctx.restore();
      } else state.toast = null;
    }
  }

  // --- win overlay & unanswered logic ---
  function showWinOverlay(){
    // compute stats
    const totalSolved = state.correct.size;
    const totalWrong = state.wrong.size;
    // which quiz indices were assigned to stars but never attempted (not in correct or wrong)
    const assigned = Array.from(state.usedQuizIndices);
    const unanswered = assigned.filter(i => !state.correct.has(i) && !state.wrong.has(i));
    const winStats = document.getElementById('winStats');
    winStats.innerHTML = <div style="font-weight:700">${totalSolved} benar • ${totalWrong} salah • ${unanswered.length} belum terjawab</div>;

    // list unanswered
    const listEl = document.getElementById('unansweredList');
    listEl.innerHTML = '';
    if (unanswered.length === 0){
      listEl.textContent = 'Tidak ada — semua soal sudah dicoba.';
    } else {
      unanswered.forEach(idx=>{
        const item = document.createElement('div');
        item.style.padding = '6px';
        item.style.borderBottom = '1px solid rgba(255,255,255,0.03)';
        item.textContent = QUIZ[idx].q;
        listEl.appendChild(item);
      });
    }

    toggleOverlay('win', true);
  }

  // --- main loop ---
  let rafId = 0;
  function loop(){
    if (state.scene !== 'play') return;
    const paused = !!state.pendingQuestion;
    if (!paused){
      handleInput();
      // physics
      updateMovingPlatforms();
      player.vy += state.gravity;
      player.x += player.vx;
      collideWorldX([...staticPlatforms, ...movingPlatforms, ...barriers.filter(b=>!b.opened)]);
      player.y += player.vy; player.onGround = false;
      collideWorldY([...staticPlatforms, ...movingPlatforms, ...barriers.filter(b=>!b.opened)]);
      carryWithMovingPlatform();
      player.x = clamp(player.x, 0, WORLD_END_X);
      player.y = Math.min(player.y, 2000);
      state.camX = clamp(player.x - BASE_W/2 + player.w/2, 0, Math.max(0, WORLD_END_X - BASE_W));
      updateEnemies();
      checkSpikes();
      checkPitFall();
      collectQuizStars();
      checkBarriersOpenByProgress();
      checkWin();
    }

    // draw using BASE coordinates
    ctx.clearRect(0,0,BASE_W,BASE_H);
    drawBackground();
    drawStaticPlatforms();
    drawMovingPlatforms();
    drawSpikes();
    drawStars();
    drawEnemies();
    drawBarriers();
    drawGoal();
    drawPlayer();
    drawHUD();

    rafId = requestAnimationFrame(loop);
  }

  // overlay utilities
  function toggleOverlay(id, show=true){
    const el = document.getElementById(id);
    if (!el) return false;
    el.style.display = show ? 'flex' : 'none';
    // pause game if overlay is shown (except loading)
    if (id !== 'loading'){
      if (show) { state.sceneOverlay = id; } else { state.sceneOverlay = null; }
    }
    return true;
  }

  // --- buttons wiring ---
  document.getElementById('startBtn').onclick = showLoading;
  document.getElementById('howBtn').onclick = ()=> toggleOverlay('how', true);
  document.getElementById('playAgainBtn').onclick = ()=> { toggleOverlay('win', false); toggleOverlay('menu', false); startGame(); };
  document.getElementById('reviewBtn').onclick = ()=> {
    // show unanswered questions in sequence (simple flow)
    const assigned = Array.from(state.usedQuizIndices);
    const unanswered = assigned.filter(i => !state.correct.has(i) && !state.wrong.has(i));
    toggleOverlay('win', false);
    if (unanswered.length === 0){ toast('Tidak ada soal belum terjawab.'); startGame(); return; }
    // put first unanswered into pendingQuestion and show quiz; remove from usedQuizIndices so it won't appear twice
    const idx = unanswered[0];
    state.pendingQuestion = {...QUIZ[idx], idx: idx, stage: null};
    showQuiz(state.pendingQuestion);
  };

  // initial setup
  genStarsForStages();
  resizeCanvas();

  // expose toggleOverlay globally (allow overlays to be closed from HTML)
  window.toggleOverlay = toggleOverlay;

  // small helper clamp used earlier - re-declare to ensure in scope
  function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }

  // start with menu visible (already)
})();
</script>
</body>
</html>
